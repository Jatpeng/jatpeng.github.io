---
title: 20250208-leetcode63不同路径2
cover: https://picsum.photos/800/600?random=<%= titleHash('20250208-leetcode63不同路径2') %>
comments: true
copyright: true
typora-root-url: ..
date: 2025-02-08 09:39:47
tags:
  - leetcode
  - 动态规划
  - 路径规划
categories:
  - 算法题解
description: LeetCode 63 - 不同路径 II，使用动态规划解决带障碍物的路径规划问题
---

## 题目描述

给定一个 m x n 的整数数组 grid。一个机器人初始位于左上角（即 grid[0][0]）。机器人尝试移动到右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含任何有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 2 * 109。

## 解题思路

这是一个典型的动态规划问题，我们可以这样解决：

1. 创建一个 dp 数组，`dp[i][j]` 表示到达位置 (i,j) 的不同路径数
2. 初始条件：
   - 如果起点有障碍物，直接返回 0
   - 否则 `dp[0][0] = 1`
3. 状态转移：
   - 如果当前位置有障碍物，`dp[i][j] = 0`
   - 否则 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`

## 代码实现

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if not obstacleGrid or obstacleGrid[0][0] == 1:
            return 0
            
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[0] * n for _ in range(m)]
        
        # 初始化第一个位置
        dp[0][0] = 1
        
        # 初始化第一行
        for j in range(1, n):
            if obstacleGrid[0][j] == 0:
                dp[0][j] = dp[0][j-1]
        
        # 初始化第一列
        for i in range(1, m):
            if obstacleGrid[i][0] == 0:
                dp[i][0] = dp[i-1][0]
        
        # 填充dp数组
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 0:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        
        return dp[m-1][n-1]
```

## 代码详解

```python
def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
    # 特判：如果网格为空或起点有障碍物，直接返回0
    if not obstacleGrid or obstacleGrid[0][0] == 1:
        return 0
    
    # 获取网格的行数和列数    
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    # 创建dp数组，初始化为0
    dp = [[0] * n for _ in range(m)]
    
    # 初始化起点(0,0)
    dp[0][0] = 1  # 起点可达，设为1
    
    # 初始化第一行：只能从左边来
    for j in range(1, n):
        # 如果当前位置没有障碍物
        if obstacleGrid[0][j] == 0:
            # 则路径数等于左边格子的路径数
            dp[0][j] = dp[0][j-1]
        # 如果有障碍物，保持为0
    
    # 初始化第一列：只能从上边来
    for i in range(1, m):
        # 如果当前位置没有障碍物
        if obstacleGrid[i][0] == 0:
            # 则路径数等于上边格子的路径数
            dp[i][0] = dp[i-1][0]
        # 如果有障碍物，保持为0
    
    # 填充剩余的dp数组
    for i in range(1, m):
        for j in range(1, n):
            # 如果当前位置没有障碍物
            if obstacleGrid[i][j] == 0:
                # 路径数 = 从上边来的路径数 + 从左边来的路径数
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            # 如果有障碍物，保持为0
    
    # 返回终点的路径数
    return dp[m-1][n-1]
```

## 复杂度分析

- 时间复杂度：O(m*n)，其中 m 和 n 分别是网格的行数和列数
- 空间复杂度：O(m*n)，需要一个二维 dp 数组来存储中间结果

## 示例分析

以题目给出的示例为例：

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：有两种不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

## 举例说明

让我们用一个具体的例子来说明：

```python
obstacleGrid = [
    [0,0,0],
    [0,1,0],
    [0,0,0]
]
```

1. 初始化 dp 数组：
```python
dp = [
    [1,0,0],  # 起点设为1
    [0,0,0],
    [0,0,0]
]
```

2. 初始化第一行：
```python
dp = [
    [1,1,1],
```

## 总结

这道题是经典动态规划问题的变体，关键点在于：

1. 处理障碍物：遇到障碍物时路径数为 0
2. 正确初始化第一行和第一列
3. 利用动态规划的状态转移方程求解

通过这道题，我们可以学习到如何在动态规划问题中处理特殊情况（障碍物），以及如何正确初始化和进行状态转移。