---
title: 20250122-leetcode_168_打家劫舍
comments: true
copyright: true
typora-root-url: ..
date: 2025-01-22 10:38:22
tags:
  - leetcode
  - 动态规划
categories:
  - 算法
description: LeetCode 198. 打家劫舍 - 动态规划解法
cover: /images/20250122-leetcode_168_打家劫舍/image-20250122104042640.png
---

## 题目

![image-20250122104042640](/images/20250122-leetcode_168_打家劫舍/image-20250122104042640.png)

## 解题思路

这是一个典型的动态规划问题。对于每个房屋，我们有两种选择：
1. 偷这个房子：那么就不能偷相邻的前一个房子，但可以偷前前一个房子
2. 不偷这个房子：那么最大金额就是偷到前一个房子为止的最大金额

定义状态：
- dp[i] 表示偷窃前i个房屋能够获得的最大金额

状态转移方程：
- dp[i] = max(dp[i-1], dp[i-2] + nums[i])
  - dp[i-1]：不偷第i个房子
  - dp[i-2] + nums[i]：偷第i个房子，加上前前个房子的最大金额

边界条件：
- dp[0] = nums[0]：只有一个房子时
- dp[1] = max(nums[0], nums[1])：有两个房子时，选择金额较大的那个

## 代码实现

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]
            
        # 初始化dp数组
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        
        # 状态转移
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])
            
        return dp[-1]
```

## 复杂度分析

- 时间复杂度：O(n)，其中n是数组的长度。我们只需要遍历一次数组。
- 空间复杂度：O(n)，需要一个dp数组来存储状态。

## 优化空间复杂度

注意到我们每次状态转移只需要前两个状态，因此可以只用两个变量来维护状态，将空间复杂度优化到O(1)：

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]
            
        prev2, prev1 = nums[0], max(nums[0], nums[1])
        
        for i in range(2, len(nums)):
            current = max(prev1, prev2 + nums[i])
            prev2, prev1 = prev1, current
            
        return prev1
```

## 总结
动态方
