---
title: 20250124_深度优先遍历问题
cover: https://picsum.photos/800/600
comments: true
copyright: true
typora-root-url: ..
date: 2025-01-24 17:32:39
tags:
categories:
description:
---

## 二叉树的最小深度问题

### 问题描述
二叉树的 最小深度 是指从根节点到最近叶子节点的最短路径上的节点数量。
注意：叶子节点是指没有子节点的节点。

### 解题思路

1. **关键点**
   - 最小深度必须是到叶子节点（没有任何子节点的节点）
   - 如果一个节点只有左子树或只有右子树，不能直接返回较小值
   - 空节点的深度为 0

2. **特殊情况处理**
   - 如果节点为空，返回 0
   - 如果节点只有左子树，最小深度是左子树的最小深度 + 1
   - 如果节点只有右子树，最小深度是右子树的最小深度 + 1
   - 如果节点有两个子树，最小深度是两个子树的最小深度的较小值 + 1

3. **DFS（深度优先搜索）过程**
   ```
   对于每个节点：
   ├── 如果节点为空
   │   └── 返回 0
   ├── 如果是叶子节点（左右子树都为空）
   │   └── 返回 1
   ├── 如果只有左子树
   │   └── 返回左子树的最小深度 + 1
   ├── 如果只有右子树
   │   └── 返回右子树的最小深度 + 1
   └── 返回 min(左子树最小深度, 右子树最小深度) + 1
   ```

4. **示例分析**
   ```
   例如对于树：
       3
      / \
     9  20
        / \
       15  7

   计算过程：
   1. 节点3有两个子节点，需要比较两边的最小深度
   2. 节点9是叶子节点，深度为1
   3. 节点20有两个子节点
   4. 节点15和7都是叶子节点，深度为1
   5. 节点20的最小深度是2
   6. 最终树的最小深度 = min(1, 2) + 1 = 2
   ```

   ```
   特殊情况示例：
       1
        \
         2
   
   这种情况下：
   - 不能返回min(0, 1) + 1 = 1
   - 应该返回2，因为必须到达叶子节点
   ```

5. **复杂度分析**
   - 时间复杂度：O(n)，其中 n 是节点数量
   - 空间复杂度：O(h)，其中 h 是树的高度，最坏情况下为 O(n)

### 代码实现

```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        # 如果根节点为空，返回0
        if not root:
            return 0
            
        # 如果是叶子节点，返回1
        if not root.left and not root.right:
            return 1
            
        # 如果只有左子树
        if not root.right:
            return self.minDepth(root.left) + 1
            
        # 如果只有右子树
        if not root.left:
            return self.minDepth(root.right) + 1
            
        # 如果左右子树都存在，返回较小的深度
        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
```

### 测试用例

```python
# 测试用例1：正常的二叉树
root = [3,9,20,null,null,15,7]
输出：2
解释：最短路径是从根节点到左子节点9，路径长度是2

# 测试用例2：只有一边的二叉树
root = [1,null,2]
输出：2
解释：最短路径是从根节点到右子节点2，路径长度是2

# 测试用例3：空树
root = []
输出：0
解释：空树的深度为0