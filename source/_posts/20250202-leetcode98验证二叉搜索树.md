---
title: 20250202-leetcode98验证二叉搜索树
cover: https://picsum.photos/800/600?random=<%= titleHash('20250202-leetcode98验证二叉搜索树') %>
comments: true
copyright: true
typora-root-url: ..
date: 2025-02-07 14:58:38
tags: 
  - leetcode
  - 二叉树
  - 递归
categories:
  - 算法题解
description: LeetCode 98 - 验证二叉搜索树，通过递归方式判断一个二叉树是否为有效的二叉搜索树
---

## 题目描述

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效二叉搜索树定义如下：
- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

## 解题思路

要验证一个二叉树是否为有效的二叉搜索树，我们需要：

1. 确保当前节点的值大于左子树的所有节点
2. 确保当前节点的值小于右子树的所有节点
3. 递归验证左右子树也满足BST的性质

关键在于维护每个节点值的合法范围。我们可以通过递归时传递上下界来实现这一点。

## 代码实现

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def validate(node, low=float('-inf'), high=float('inf')):
            # 空节点认为是有效的BST
            if not node:
                return True
                
            # 判断当前节点值是否在合法范围内
            if node.val <= low or node.val >= high:
                return False
                
            # 递归验证左右子树
            # 左子树的所有节点值必须小于当前节点值
            # 右子树的所有节点值必须大于当前节点值
            return validate(node.left, low, node.val) and validate(node.right, node.val, high)
        
        return validate(root)



